"""
Universal Binary Principle (UBP) Framework v3.1 - Enhanced RGDL Engine Module

This module implements the Resonance Geometry Definition Language (RGDL)
Geometric Execution Engine, providing dynamic geometry generation through
emergent behavior of binary toggles operating under specific resonance
frequencies and coherence constraints.

Enhanced for v3.1 with improved integration with v3.0 components and
better performance optimization.

Author: Euan Craig
Version: 3.1
Date: August 2025
"""

import numpy as np
from typing import Dict, Any, List, Tuple, Optional, Union, Callable
from dataclasses import dataclass
import json
import math
import time
from scipy.spatial import ConvexHull, Voronoi
from scipy.spatial.distance import pdist, squareform
from scipy.optimize import minimize

try:
    from .core import UBPConstants
    from .bitfield import Bitfield, OffBit
    from .toggle_algebra import ToggleAlgebra
    from .hex_dictionary import HexDictionary
except ImportError:
    from core import UBPConstants
    from bitfield import Bitfield, OffBit
    from toggle_algebra import ToggleAlgebra
    from hex_dictionary import HexDictionary


@dataclass
class GeometricPrimitive:
    """A geometric primitive generated by RGDL."""
    primitive_type: str
    coordinates: np.ndarray
    properties: Dict[str, Any]
    resonance_frequency: float
    coherence_level: float
    generation_method: str
    stability_score: float
    creation_timestamp: float
    nrci_score: float = 0.0


@dataclass
class RGDLMetrics:
    """Performance and quality metrics for RGDL operations."""
    total_primitives_generated: int
    average_coherence: float
    average_stability: float
    geometric_complexity: float
    resonance_distribution: Dict[str, int]
    generation_time: float
    memory_usage_mb: float
    nrci_average: float = 0.0


@dataclass
class GeometricField:
    """A field of geometric primitives with spatial relationships."""
    field_name: str
    primitives: List[GeometricPrimitive]
    spatial_bounds: Tuple[Tuple[float, float], Tuple[float, float], Tuple[float, float]]
    field_coherence: float
    resonance_pattern: np.ndarray
    interaction_matrix: np.ndarray
    field_energy: float = 0.0


class RGDLEngine:
    """
    Enhanced Resonance Geometry Definition Language (RGDL) Execution Engine.
    
    This engine generates geometric primitives through the emergent behavior
    of binary toggles operating under specific resonance frequencies and
    coherence constraints within the UBP framework.
    
    Enhanced for v3.1 with better integration and performance.
    """
    
    def __init__(self, bitfield_instance: Optional[Bitfield] = None,
                 toggle_algebra_instance: Optional[ToggleAlgebra] = None,
                 hex_dictionary_instance: Optional[HexDictionary] = None):
        """
        Initialize the RGDL Engine.
        
        Args:
            bitfield_instance: Optional Bitfield instance for geometric operations
            toggle_algebra_instance: Optional ToggleAlgebra instance for computations
            hex_dictionary_instance: Optional HexDictionary for data storage
        """
        self.bitfield = bitfield_instance
        self.toggle_algebra = toggle_algebra_instance
        self.hex_dictionary = hex_dictionary_instance or HexDictionary()
        
        # Geometric primitive generators
        self.primitive_generators = {
            'point': self._generate_point,
            'line': self._generate_line,
            'triangle': self._generate_triangle,
            'tetrahedron': self._generate_tetrahedron,
            'cube': self._generate_cube,
            'sphere': self._generate_sphere,
            'torus': self._generate_torus,
            'fractal': self._generate_fractal,
            'resonance_surface': self._generate_resonance_surface,
            'quantum_geometry': self._generate_quantum_geometry,  # New for v3.1
            'htr_structure': self._generate_htr_structure,  # New for v3.1
            'crv_manifold': self._generate_crv_manifold,  # New for v3.1
        }
        
        # Resonance frequency mappings
        self.resonance_frequencies = {
            'quantum': UBPConstants.CRV_QUANTUM,
            'electromagnetic': UBPConstants.CRV_ELECTROMAGNETIC,
            'gravitational': UBPConstants.CRV_GRAVITATIONAL,
            'biological': UBPConstants.CRV_BIOLOGICAL,
            'cosmological': UBPConstants.CRV_COSMOLOGICAL,
            'nuclear': UBPConstants.CRV_NUCLEAR,
            'optical': UBPConstants.CRV_OPTICAL
        }
        
        # Generated primitives storage
        self.primitives: List[GeometricPrimitive] = []
        self.geometric_fields: Dict[str, GeometricField] = {}
        
        # Performance metrics
        self.metrics = RGDLMetrics(
            total_primitives_generated=0,
            average_coherence=0.0,
            average_stability=0.0,
            geometric_complexity=0.0,
            resonance_distribution={},
            generation_time=0.0,
            memory_usage_mb=0.0
        )
        
        # Geometry cache for performance
        self.geometry_cache: Dict[str, GeometricPrimitive] = {}
        
        print("âœ… RGDL Engine v3.1 Initialized")
        print(f"   Supported Primitives: {len(self.primitive_generators)}")
        print(f"   Resonance Frequencies: {len(self.resonance_frequencies)}")
        print(f"   HexDictionary Integration: {'Enabled' if self.hex_dictionary else 'Disabled'}")
    
    # ========================================================================
    # CORE GEOMETRY GENERATION METHODS
    # ========================================================================
    
    def generate_primitive(self, primitive_type: str, 
                          resonance_realm: str = 'electromagnetic',
                          parameters: Optional[Dict[str, Any]] = None) -> GeometricPrimitive:
        """
        Generate a geometric primitive of the specified type.
        
        Args:
            primitive_type: Type of primitive to generate
            resonance_realm: Realm for resonance frequency selection
            parameters: Optional parameters for generation
            
        Returns:
            Generated GeometricPrimitive
        """
        start_time = time.time()
        
        if primitive_type not in self.primitive_generators:
            raise ValueError(f"Unsupported primitive type: {primitive_type}")
        
        if resonance_realm not in self.resonance_frequencies:
            raise ValueError(f"Unsupported resonance realm: {resonance_realm}")
        
        # Get resonance frequency
        resonance_freq = self.resonance_frequencies[resonance_realm]
        
        # Generate cache key
        cache_key = f"{primitive_type}_{resonance_realm}_{hash(str(parameters))}"
        
        # Check cache first
        if cache_key in self.geometry_cache:
            cached_primitive = self.geometry_cache[cache_key]
            cached_primitive.creation_timestamp = time.time()
            return cached_primitive
        
        # Generate the primitive
        generator = self.primitive_generators[primitive_type]
        primitive = generator(resonance_freq, parameters or {})
        
        # Calculate coherence and stability
        primitive.coherence_level = self._calculate_coherence(primitive)
        primitive.stability_score = self._calculate_stability(primitive)
        primitive.nrci_score = self._calculate_nrci(primitive)
        primitive.creation_timestamp = time.time()
        
        # Store in cache
        self.geometry_cache[cache_key] = primitive
        
        # Store in HexDictionary if available
        if self.hex_dictionary:
            geometry_data = {
                'type': primitive_type,
                'coordinates': primitive.coordinates.tolist(),
                'properties': primitive.properties,
                'resonance_frequency': primitive.resonance_frequency,
                'coherence_level': primitive.coherence_level,
                'stability_score': primitive.stability_score,
                'nrci_score': primitive.nrci_score
            }
            self.hex_dictionary.store(geometry_data, 'json', 
                                    {'primitive_type': primitive_type, 
                                     'resonance_realm': resonance_realm})
        
        # Update metrics
        self.primitives.append(primitive)
        self._update_metrics(primitive, time.time() - start_time)
        
        return primitive
    
    def _generate_point(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced point."""
        # Use resonance frequency to influence position
        phase = params.get('phase', 0.0)
        amplitude = params.get('amplitude', 1.0)
        
        x = amplitude * np.cos(2 * np.pi * resonance_freq * phase)
        y = amplitude * np.sin(2 * np.pi * resonance_freq * phase)
        z = amplitude * np.cos(np.pi * resonance_freq * phase)
        
        coordinates = np.array([x, y, z])
        
        return GeometricPrimitive(
            primitive_type='point',
            coordinates=coordinates,
            properties={'amplitude': amplitude, 'phase': phase},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,  # Will be calculated later
            generation_method='resonance_oscillation',
            stability_score=0.0,  # Will be calculated later
            creation_timestamp=time.time()
        )
    
    def _generate_line(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced line segment."""
        length = params.get('length', 1.0)
        direction = params.get('direction', np.array([1, 0, 0]))
        start_point = params.get('start_point', np.array([0, 0, 0]))
        
        # Normalize direction
        direction = direction / np.linalg.norm(direction)
        
        # Create line points influenced by resonance
        num_points = params.get('num_points', 100)
        t_values = np.linspace(0, length, num_points)
        
        # Add resonance-based perturbation
        perturbation_amplitude = params.get('perturbation', 0.01)
        perturbation = perturbation_amplitude * np.sin(2 * np.pi * resonance_freq * t_values)
        
        coordinates = np.array([start_point + t * direction + 
                              perturbation[i] * np.array([0, 1, 0]) 
                              for i, t in enumerate(t_values)])
        
        return GeometricPrimitive(
            primitive_type='line',
            coordinates=coordinates,
            properties={'length': length, 'direction': direction.tolist(), 
                       'perturbation_amplitude': perturbation_amplitude},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_perturbation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_triangle(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced triangle."""
        center = params.get('center', np.array([0, 0, 0]))
        radius = params.get('radius', 1.0)
        
        # Generate triangle vertices with resonance influence
        angles = np.array([0, 2*np.pi/3, 4*np.pi/3])
        resonance_modulation = 1 + 0.1 * np.sin(2 * np.pi * resonance_freq * angles)
        
        vertices = []
        for i, angle in enumerate(angles):
            x = center[0] + radius * resonance_modulation[i] * np.cos(angle)
            y = center[1] + radius * resonance_modulation[i] * np.sin(angle)
            z = center[2]
            vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='triangle',
            coordinates=coordinates,
            properties={'center': center.tolist(), 'radius': radius, 
                       'resonance_modulation': resonance_modulation.tolist()},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_modulation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_tetrahedron(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced tetrahedron."""
        center = params.get('center', np.array([0, 0, 0]))
        edge_length = params.get('edge_length', 1.0)
        
        # Standard tetrahedron vertices
        a = edge_length / np.sqrt(2)
        vertices = np.array([
            [a, a, a],
            [a, -a, -a],
            [-a, a, -a],
            [-a, -a, a]
        ]) + center
        
        # Apply resonance-based deformation
        deformation_factor = 0.1 * np.sin(2 * np.pi * resonance_freq)
        vertices *= (1 + deformation_factor)
        
        return GeometricPrimitive(
            primitive_type='tetrahedron',
            coordinates=vertices,
            properties={'center': center.tolist(), 'edge_length': edge_length,
                       'deformation_factor': deformation_factor},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_deformation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_cube(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced cube."""
        center = params.get('center', np.array([0, 0, 0]))
        side_length = params.get('side_length', 1.0)
        
        # Generate cube vertices
        half_side = side_length / 2
        vertices = []
        
        for x in [-half_side, half_side]:
            for y in [-half_side, half_side]:
                for z in [-half_side, half_side]:
                    # Apply resonance-based position adjustment
                    resonance_shift = 0.05 * np.sin(2 * np.pi * resonance_freq * (x + y + z))
                    vertex = center + np.array([x, y, z]) * (1 + resonance_shift)
                    vertices.append(vertex)
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='cube',
            coordinates=coordinates,
            properties={'center': center.tolist(), 'side_length': side_length},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_vertex_shift',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_sphere(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced sphere."""
        center = params.get('center', np.array([0, 0, 0]))
        radius = params.get('radius', 1.0)
        resolution = params.get('resolution', 50)
        
        # Generate sphere points
        phi = np.linspace(0, np.pi, resolution)
        theta = np.linspace(0, 2*np.pi, resolution)
        
        vertices = []
        for p in phi:
            for t in theta:
                # Apply resonance-based radius modulation
                r_modulated = radius * (1 + 0.1 * np.sin(2 * np.pi * resonance_freq * (p + t)))
                
                x = center[0] + r_modulated * np.sin(p) * np.cos(t)
                y = center[1] + r_modulated * np.sin(p) * np.sin(t)
                z = center[2] + r_modulated * np.cos(p)
                
                vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='sphere',
            coordinates=coordinates,
            properties={'center': center.tolist(), 'radius': radius, 'resolution': resolution},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_radius_modulation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_torus(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced torus."""
        center = params.get('center', np.array([0, 0, 0]))
        major_radius = params.get('major_radius', 1.0)
        minor_radius = params.get('minor_radius', 0.3)
        resolution = params.get('resolution', 30)
        
        # Generate torus points
        u = np.linspace(0, 2*np.pi, resolution)
        v = np.linspace(0, 2*np.pi, resolution)
        
        vertices = []
        for u_val in u:
            for v_val in v:
                # Apply resonance-based modulation
                resonance_factor = 1 + 0.1 * np.sin(2 * np.pi * resonance_freq * (u_val + v_val))
                
                x = center[0] + (major_radius + minor_radius * np.cos(v_val)) * np.cos(u_val) * resonance_factor
                y = center[1] + (major_radius + minor_radius * np.cos(v_val)) * np.sin(u_val) * resonance_factor
                z = center[2] + minor_radius * np.sin(v_val) * resonance_factor
                
                vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='torus',
            coordinates=coordinates,
            properties={'center': center.tolist(), 'major_radius': major_radius, 
                       'minor_radius': minor_radius, 'resolution': resolution},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_torus_modulation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_fractal(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a resonance-influenced fractal structure."""
        iterations = params.get('iterations', 5)
        scale_factor = params.get('scale_factor', 0.5)
        base_shape = params.get('base_shape', 'triangle')
        
        # Start with base shape
        if base_shape == 'triangle':
            base_vertices = np.array([[0, 0, 0], [1, 0, 0], [0.5, np.sqrt(3)/2, 0]])
        else:
            base_vertices = np.array([[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]])
        
        # Apply fractal generation with resonance influence
        all_vertices = [base_vertices]
        
        for iteration in range(iterations):
            new_vertices = []
            resonance_scale = 1 + 0.1 * np.sin(2 * np.pi * resonance_freq * iteration)
            
            for vertex_set in all_vertices:
                # Create smaller copies at each vertex
                for vertex in vertex_set:
                    scaled_shape = vertex + (vertex_set - vertex_set[0]) * scale_factor * resonance_scale
                    new_vertices.append(scaled_shape)
            
            all_vertices.extend(new_vertices)
        
        # Flatten all vertices
        coordinates = np.vstack(all_vertices)
        
        return GeometricPrimitive(
            primitive_type='fractal',
            coordinates=coordinates,
            properties={'iterations': iterations, 'scale_factor': scale_factor, 
                       'base_shape': base_shape},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_fractal_scaling',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_resonance_surface(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate a surface based on resonance patterns."""
        x_range = params.get('x_range', (-2, 2))
        y_range = params.get('y_range', (-2, 2))
        resolution = params.get('resolution', 50)
        
        x = np.linspace(x_range[0], x_range[1], resolution)
        y = np.linspace(y_range[0], y_range[1], resolution)
        X, Y = np.meshgrid(x, y)
        
        # Generate resonance-based surface
        Z = np.sin(2 * np.pi * resonance_freq * X) * np.cos(2 * np.pi * resonance_freq * Y)
        Z += 0.5 * np.sin(4 * np.pi * resonance_freq * np.sqrt(X**2 + Y**2))
        
        # Convert to vertex array
        vertices = []
        for i in range(resolution):
            for j in range(resolution):
                vertices.append([X[i, j], Y[i, j], Z[i, j]])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='resonance_surface',
            coordinates=coordinates,
            properties={'x_range': x_range, 'y_range': y_range, 'resolution': resolution},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='resonance_wave_interference',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    # New v3.1 generators
    def _generate_quantum_geometry(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate quantum-influenced geometry using UBP principles."""
        quantum_states = params.get('quantum_states', 4)
        superposition_factor = params.get('superposition_factor', 0.5)
        
        # Generate quantum state positions
        vertices = []
        for state in range(quantum_states):
            # Use quantum CRV for positioning
            phase = 2 * np.pi * state / quantum_states
            quantum_crv = UBPConstants.CRV_QUANTUM
            
            x = np.cos(phase) * (1 + superposition_factor * np.sin(2 * np.pi * quantum_crv * state))
            y = np.sin(phase) * (1 + superposition_factor * np.cos(2 * np.pi * quantum_crv * state))
            z = superposition_factor * np.sin(2 * np.pi * quantum_crv * phase)
            
            vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='quantum_geometry',
            coordinates=coordinates,
            properties={'quantum_states': quantum_states, 'superposition_factor': superposition_factor},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='quantum_superposition',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_htr_structure(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate HTR (Harmonic Toggle Resonance) influenced structure."""
        harmonic_order = params.get('harmonic_order', 3)
        toggle_frequency = params.get('toggle_frequency', 1.0)
        
        # Generate HTR pattern
        t = np.linspace(0, 2*np.pi, 100)
        vertices = []
        
        for i in range(harmonic_order):
            harmonic_freq = (i + 1) * toggle_frequency
            amplitude = 1.0 / (i + 1)  # Decreasing amplitude for higher harmonics
            
            x = amplitude * np.cos(harmonic_freq * t) * np.cos(2 * np.pi * resonance_freq * t)
            y = amplitude * np.sin(harmonic_freq * t) * np.sin(2 * np.pi * resonance_freq * t)
            z = amplitude * np.sin(2 * harmonic_freq * t)
            
            for j in range(len(t)):
                vertices.append([x[j], y[j], z[j]])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='htr_structure',
            coordinates=coordinates,
            properties={'harmonic_order': harmonic_order, 'toggle_frequency': toggle_frequency},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='harmonic_toggle_resonance',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    def _generate_crv_manifold(self, resonance_freq: float, params: Dict[str, Any]) -> GeometricPrimitive:
        """Generate manifold based on Core Resonance Values."""
        crv_type = params.get('crv_type', 'electromagnetic')
        manifold_dimension = params.get('manifold_dimension', 2)
        
        # Get appropriate CRV
        crv_value = self.resonance_frequencies.get(crv_type, UBPConstants.CRV_ELECTROMAGNETIC)
        
        # Generate manifold points
        if manifold_dimension == 2:
            u = np.linspace(0, 2*np.pi, 50)
            v = np.linspace(0, np.pi, 25)
            U, V = np.meshgrid(u, v)
            
            # CRV-influenced manifold
            X = np.cos(U) * np.sin(V) * (1 + 0.1 * np.sin(crv_value * U))
            Y = np.sin(U) * np.sin(V) * (1 + 0.1 * np.cos(crv_value * V))
            Z = np.cos(V) * (1 + 0.1 * np.sin(crv_value * (U + V)))
            
            vertices = []
            for i in range(X.shape[0]):
                for j in range(X.shape[1]):
                    vertices.append([X[i, j], Y[i, j], Z[i, j]])
        else:
            # 1D manifold (curve)
            t = np.linspace(0, 4*np.pi, 200)
            vertices = []
            
            for i, t_val in enumerate(t):
                x = np.cos(t_val) * (1 + 0.2 * np.sin(crv_value * t_val))
                y = np.sin(t_val) * (1 + 0.2 * np.cos(crv_value * t_val))
                z = 0.5 * np.sin(2 * t_val) * np.sin(crv_value * t_val)
                vertices.append([x, y, z])
        
        coordinates = np.array(vertices)
        
        return GeometricPrimitive(
            primitive_type='crv_manifold',
            coordinates=coordinates,
            properties={'crv_type': crv_type, 'manifold_dimension': manifold_dimension, 'crv_value': crv_value},
            resonance_frequency=resonance_freq,
            coherence_level=0.0,
            generation_method='crv_manifold_generation',
            stability_score=0.0,
            creation_timestamp=time.time()
        )
    
    # ========================================================================
    # ANALYSIS AND METRICS
    # ========================================================================
    
    def _calculate_coherence(self, primitive: GeometricPrimitive) -> float:
        """Calculate coherence level for a geometric primitive."""
        # Handle single point case
        if primitive.primitive_type == 'point' or len(primitive.coordinates.shape) == 1:
            # For a single point, coherence is based on coordinate regularity
            coords = primitive.coordinates.flatten()
            if len(coords) < 2:
                return 1.0
            
            # Calculate variance of coordinates as a measure of coherence
            coord_variance = np.var(coords)
            coord_mean = np.mean(np.abs(coords))
            
            if coord_mean > 0:
                coherence = 1.0 / (1.0 + coord_variance / coord_mean)
            else:
                coherence = 1.0
            
            return min(max(coherence, 0.0), 1.0)
        
        # Handle multi-point primitives
        if len(primitive.coordinates) < 2:
            return 1.0
        
        # Ensure coordinates are in the right shape for pdist
        coords = np.array(primitive.coordinates)
        if coords.ndim == 1:
            # Single point - reshape to 2D
            coords = coords.reshape(1, -1)
        elif coords.ndim == 2 and coords.shape[0] == 1:
            # Single point in 2D array
            return 1.0
        
        # Calculate spatial coherence based on coordinate regularity
        try:
            distances = pdist(coords)
            if len(distances) == 0:
                return 1.0
            
            distance_variance = np.var(distances)
            distance_mean = np.mean(distances)
            
            # Coherence is inversely related to relative variance
            if distance_mean > 0:
                coherence = 1.0 / (1.0 + distance_variance / distance_mean)
            else:
                coherence = 1.0
        except Exception:
            # Fallback for any array shape issues
            coherence = 1.0
        
        return min(1.0, max(0.0, coherence))
    
    def _calculate_stability(self, primitive: GeometricPrimitive) -> float:
        """Calculate stability score for a geometric primitive."""
        if len(primitive.coordinates) < 3:
            return 1.0
        
        # Calculate stability based on geometric properties
        try:
            # For 3D primitives, calculate convex hull volume stability
            if primitive.coordinates.shape[1] >= 3:
                hull = ConvexHull(primitive.coordinates)
                volume = hull.volume
                surface_area = hull.area
                
                # Stability related to volume-to-surface ratio
                if surface_area > 0:
                    stability = volume / surface_area
                else:
                    stability = 0.0
            else:
                # For 2D or 1D, use coordinate spread
                coord_range = np.ptp(primitive.coordinates, axis=0)
                stability = 1.0 / (1.0 + np.std(coord_range))
        except:
            # Fallback calculation
            coord_std = np.std(primitive.coordinates)
            stability = 1.0 / (1.0 + coord_std)
        
        return min(1.0, max(0.0, stability))
    
    def _calculate_nrci(self, primitive: GeometricPrimitive) -> float:
        """Calculate Non-Random Coherence Index for the primitive."""
        if len(primitive.coordinates) < 2:
            return 1.0
        
        # Calculate NRCI based on coordinate patterns
        coords_flat = primitive.coordinates.flatten()
        
        # Generate expected pattern based on resonance frequency
        t = np.linspace(0, 1, len(coords_flat))
        expected_pattern = np.sin(2 * np.pi * primitive.resonance_frequency * t)
        
        # Normalize both signals
        if np.std(coords_flat) > 0:
            coords_normalized = (coords_flat - np.mean(coords_flat)) / np.std(coords_flat)
        else:
            coords_normalized = coords_flat
        
        if np.std(expected_pattern) > 0:
            pattern_normalized = (expected_pattern - np.mean(expected_pattern)) / np.std(expected_pattern)
        else:
            pattern_normalized = expected_pattern
        
        # Calculate correlation
        if len(coords_normalized) == len(pattern_normalized):
            correlation = np.corrcoef(coords_normalized, pattern_normalized)[0, 1]
            if np.isnan(correlation):
                correlation = 0.0
        else:
            correlation = 0.0
        
        # Convert correlation to NRCI (0 to 1 scale)
        nrci = (correlation + 1) / 2
        
        return min(1.0, max(0.0, nrci))
    
    def _update_metrics(self, primitive: GeometricPrimitive, generation_time: float) -> None:
        """Update performance metrics after generating a primitive."""
        self.metrics.total_primitives_generated += 1
        self.metrics.generation_time += generation_time
        
        # Update averages
        total = self.metrics.total_primitives_generated
        self.metrics.average_coherence = ((self.metrics.average_coherence * (total - 1)) + 
                                        primitive.coherence_level) / total
        self.metrics.average_stability = ((self.metrics.average_stability * (total - 1)) + 
                                        primitive.stability_score) / total
        self.metrics.nrci_average = ((self.metrics.nrci_average * (total - 1)) + 
                                   primitive.nrci_score) / total
        
        # Update resonance distribution
        realm = self._get_realm_from_frequency(primitive.resonance_frequency)
        self.metrics.resonance_distribution[realm] = self.metrics.resonance_distribution.get(realm, 0) + 1
        
        # Calculate geometric complexity (based on number of vertices)
        complexity = len(primitive.coordinates) / 1000.0  # Normalize
        self.metrics.geometric_complexity = ((self.metrics.geometric_complexity * (total - 1)) + 
                                           complexity) / total
    
    def _get_realm_from_frequency(self, frequency: float) -> str:
        """Get realm name from resonance frequency."""
        for realm, freq in self.resonance_frequencies.items():
            if abs(freq - frequency) < 1e-10:
                return realm
        return 'unknown'
    
    # ========================================================================
    # GEOMETRIC FIELD OPERATIONS
    # ========================================================================
    
    def create_geometric_field(self, field_name: str, primitives: List[GeometricPrimitive]) -> GeometricField:
        """
        Create a geometric field from a collection of primitives.
        
        Args:
            field_name: Name for the geometric field
            primitives: List of geometric primitives
            
        Returns:
            Created GeometricField
        """
        if not primitives:
            raise ValueError("Cannot create field with no primitives")
        
        # Calculate spatial bounds
        all_coords = np.vstack([p.coordinates for p in primitives])
        x_bounds = (np.min(all_coords[:, 0]), np.max(all_coords[:, 0]))
        y_bounds = (np.min(all_coords[:, 1]), np.max(all_coords[:, 1]))
        z_bounds = (np.min(all_coords[:, 2]), np.max(all_coords[:, 2]))
        
        # Calculate field coherence
        coherences = [p.coherence_level for p in primitives]
        field_coherence = np.mean(coherences)
        
        # Generate resonance pattern
        resonance_pattern = np.array([p.resonance_frequency for p in primitives])
        
        # Calculate interaction matrix
        n_primitives = len(primitives)
        interaction_matrix = np.zeros((n_primitives, n_primitives))
        
        for i in range(n_primitives):
            for j in range(i + 1, n_primitives):
                # Calculate interaction strength based on resonance similarity
                freq_diff = abs(primitives[i].resonance_frequency - primitives[j].resonance_frequency)
                interaction_strength = np.exp(-freq_diff / 1000.0)  # Decay with frequency difference
                interaction_matrix[i, j] = interaction_strength
                interaction_matrix[j, i] = interaction_strength
        
        # Calculate field energy
        field_energy = np.sum([p.resonance_frequency * p.coherence_level for p in primitives])
        
        field = GeometricField(
            field_name=field_name,
            primitives=primitives,
            spatial_bounds=(x_bounds, y_bounds, z_bounds),
            field_coherence=field_coherence,
            resonance_pattern=resonance_pattern,
            interaction_matrix=interaction_matrix,
            field_energy=field_energy
        )
        
        self.geometric_fields[field_name] = field
        
        # Store in HexDictionary if available
        if self.hex_dictionary:
            field_data = {
                'field_name': field_name,
                'num_primitives': len(primitives),
                'spatial_bounds': field.spatial_bounds,
                'field_coherence': field_coherence,
                'field_energy': field_energy,
                'primitive_types': [p.primitive_type for p in primitives]
            }
            self.hex_dictionary.store(field_data, 'json', {'field_name': field_name})
        
        return field
    
    def analyze_field_interactions(self, field_name: str) -> Dict[str, Any]:
        """
        Analyze interactions within a geometric field.
        
        Args:
            field_name: Name of the field to analyze
            
        Returns:
            Dictionary with interaction analysis results
        """
        if field_name not in self.geometric_fields:
            raise ValueError(f"Field {field_name} not found")
        
        field = self.geometric_fields[field_name]
        
        # Analyze interaction matrix
        interaction_strength = np.mean(field.interaction_matrix)
        max_interaction = np.max(field.interaction_matrix)
        min_interaction = np.min(field.interaction_matrix)
        
        # Find strongest interacting pairs
        n = field.interaction_matrix.shape[0]
        strongest_pairs = []
        
        for i in range(n):
            for j in range(i + 1, n):
                strength = field.interaction_matrix[i, j]
                strongest_pairs.append((i, j, strength))
        
        strongest_pairs.sort(key=lambda x: x[2], reverse=True)
        top_pairs = strongest_pairs[:5]  # Top 5 interactions
        
        # Calculate field stability
        eigenvalues = np.linalg.eigvals(field.interaction_matrix)
        field_stability = np.real(np.max(eigenvalues))
        
        return {
            'field_name': field_name,
            'average_interaction_strength': interaction_strength,
            'max_interaction_strength': max_interaction,
            'min_interaction_strength': min_interaction,
            'field_stability': field_stability,
            'strongest_interactions': top_pairs,
            'field_coherence': field.field_coherence,
            'field_energy': field.field_energy,
            'num_primitives': len(field.primitives)
        }
    
    # ========================================================================
    # UTILITY METHODS
    # ========================================================================
    
    def get_metrics(self) -> RGDLMetrics:
        """Get current RGDL engine metrics."""
        return self.metrics
    
    def clear_cache(self) -> None:
        """Clear the geometry cache."""
        self.geometry_cache.clear()
        print("âœ… RGDL geometry cache cleared")
    
    def export_primitives(self, file_path: str) -> bool:
        """
        Export all generated primitives to a file.
        
        Args:
            file_path: Path to export file
            
        Returns:
            True if successful, False otherwise
        """
        try:
            export_data = {
                'primitives': [],
                'metrics': self.metrics.__dict__,
                'geometric_fields': {}
            }
            
            # Export primitives
            for primitive in self.primitives:
                primitive_data = {
                    'primitive_type': primitive.primitive_type,
                    'coordinates': primitive.coordinates.tolist(),
                    'properties': primitive.properties,
                    'resonance_frequency': primitive.resonance_frequency,
                    'coherence_level': primitive.coherence_level,
                    'generation_method': primitive.generation_method,
                    'stability_score': primitive.stability_score,
                    'creation_timestamp': primitive.creation_timestamp,
                    'nrci_score': primitive.nrci_score
                }
                export_data['primitives'].append(primitive_data)
            
            # Export geometric fields
            for field_name, field in self.geometric_fields.items():
                field_data = {
                    'field_name': field.field_name,
                    'spatial_bounds': field.spatial_bounds,
                    'field_coherence': field.field_coherence,
                    'resonance_pattern': field.resonance_pattern.tolist(),
                    'interaction_matrix': field.interaction_matrix.tolist(),
                    'field_energy': field.field_energy,
                    'num_primitives': len(field.primitives)
                }
                export_data['geometric_fields'][field_name] = field_data
            
            with open(file_path, 'w') as f:
                json.dump(export_data, f, indent=2, default=str)
            
            print(f"âœ… Exported {len(self.primitives)} primitives to {file_path}")
            return True
            
        except Exception as e:
            print(f"âŒ Export failed: {e}")
            return False
    
    def generate_batch_primitives(self, batch_config: List[Dict[str, Any]]) -> List[GeometricPrimitive]:
        """
        Generate multiple primitives in batch for efficiency.
        
        Args:
            batch_config: List of configuration dictionaries for each primitive
            
        Returns:
            List of generated primitives
        """
        start_time = time.time()
        generated_primitives = []
        
        for config in batch_config:
            primitive_type = config.get('type', 'point')
            resonance_realm = config.get('realm', 'electromagnetic')
            parameters = config.get('parameters', {})
            
            try:
                primitive = self.generate_primitive(primitive_type, resonance_realm, parameters)
                generated_primitives.append(primitive)
            except Exception as e:
                print(f"âš ï¸  Failed to generate {primitive_type}: {e}")
                continue
        
        batch_time = time.time() - start_time
        print(f"âœ… Generated {len(generated_primitives)} primitives in {batch_time:.3f}s")
        
        return generated_primitives


# ========================================================================
# UTILITY FUNCTIONS
# ========================================================================

def create_rgdl_engine(bitfield: Optional[Bitfield] = None,
                      toggle_algebra: Optional[ToggleAlgebra] = None,
                      hex_dictionary: Optional[HexDictionary] = None) -> RGDLEngine:
    """
    Create and return a new RGDL Engine instance.
    
    Args:
        bitfield: Optional Bitfield instance
        toggle_algebra: Optional ToggleAlgebra instance
        hex_dictionary: Optional HexDictionary instance
        
    Returns:
        Initialized RGDLEngine instance
    """
    return RGDLEngine(bitfield, toggle_algebra, hex_dictionary)


def benchmark_rgdl_engine(engine: RGDLEngine, num_primitives: int = 100) -> Dict[str, float]:
    """
    Benchmark RGDL Engine performance.
    
    Args:
        engine: RGDLEngine instance to benchmark
        num_primitives: Number of primitives to generate
        
    Returns:
        Dictionary with benchmark results
    """
    start_time = time.time()
    
    # Generate various primitive types
    primitive_types = ['point', 'line', 'triangle', 'sphere', 'cube']
    realms = ['quantum', 'electromagnetic', 'gravitational', 'biological']
    
    generation_times = []
    
    for i in range(num_primitives):
        primitive_type = primitive_types[i % len(primitive_types)]
        realm = realms[i % len(realms)]
        
        gen_start = time.time()
        engine.generate_primitive(primitive_type, realm)
        generation_times.append(time.time() - gen_start)
    
    total_time = time.time() - start_time
    
    return {
        'total_time': total_time,
        'average_generation_time': np.mean(generation_times),
        'primitives_per_second': num_primitives / total_time,
        'total_primitives_generated': engine.metrics.total_primitives_generated,
        'average_coherence': engine.metrics.average_coherence,
        'average_stability': engine.metrics.average_stability,
        'average_nrci': engine.metrics.nrci_average
    }


if __name__ == "__main__":
    # Test the RGDL Engine
    print("ðŸ§ª Testing RGDL Engine v3.1...")
    
    engine = create_rgdl_engine()
    
    # Test basic primitive generation
    point = engine.generate_primitive('point', 'quantum')
    line = engine.generate_primitive('line', 'electromagnetic')
    sphere = engine.generate_primitive('sphere', 'gravitational')
    
    print(f"Generated point: coherence={point.coherence_level:.3f}, NRCI={point.nrci_score:.3f}")
    print(f"Generated line: coherence={line.coherence_level:.3f}, NRCI={line.nrci_score:.3f}")
    print(f"Generated sphere: coherence={sphere.coherence_level:.3f}, NRCI={sphere.nrci_score:.3f}")
    
    # Test geometric field creation
    field = engine.create_geometric_field('test_field', [point, line, sphere])
    field_analysis = engine.analyze_field_interactions('test_field')
    
    print(f"Field coherence: {field_analysis['field_coherence']:.3f}")
    print(f"Field energy: {field_analysis['field_energy']:.3f}")
    
    # Test metrics
    metrics = engine.get_metrics()
    print(f"Total primitives: {metrics.total_primitives_generated}")
    print(f"Average coherence: {metrics.average_coherence:.3f}")
    print(f"Average NRCI: {metrics.nrci_average:.3f}")
    
    print("âœ… RGDL Engine v3.1 test completed successfully!")

